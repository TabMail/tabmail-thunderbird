import { formatTimestampForAgent } from "../../chat/modules/helpers.js";
import { SETTINGS } from "./config.js";
import { isInboxFolder } from "./folderUtils.js";
import { getSummary } from "./summaryGenerator.js";
import { ACTION_TAG_IDS } from "./tagHelper.js";
import { getUniqueMessageKey, log } from "./utils.js";

// NOTE: isInboxFolder moved to folderUtils.js to avoid circular dependencies.

/**
 * Get the total count of messages in all inboxes
 * @returns {Promise<number>} Total count of inbox messages across all accounts
 */
export async function getTotalInboxCount() {
  let totalCount = 0;
  
  try {
    const accounts = await browser.accounts.list();
    
    for (const acc of accounts) {
      try {
        if (!acc.rootFolder) continue;
        
        const inboxFolder = await getInboxForAccount(acc.id);
        if (!inboxFolder) continue;
        
        // Paginate to count all messages
        let page = await browser.messages.list(inboxFolder.id);
        while (page && page.messages && page.messages.length > 0) {
          totalCount += page.messages.length;
          if (page.id) {
            page = await browser.messages.continueList(page.id);
          } else {
            break;
          }
        }
      } catch (e) {
        log(`[InboxContext] Error counting messages for account ${acc.name}: ${e}`, "warn");
      }
    }
  } catch (e) {
    log(`[InboxContext] Error getting total inbox count: ${e}`, "error");
  }
  
  log(`[InboxContext] Total inbox count: ${totalCount}`, 'debug');
  return totalCount;
}

/**
 * Get the inbox folder for a given account
 */
export async function getInboxForAccount(accountId) {
  try {
    const accounts = await browser.accounts.list();
    const account = accounts.find(acc => acc.id === accountId);
    
    if (!account?.rootFolder) {
      log(`[InboxLookup] No root folder for account ${accountId}`, 'debug');
      return null;
    }
    
    const subFolders = await browser.folders.getSubFolders(account.rootFolder.id, true);
    const allFolders = [account.rootFolder, ...subFolders];
    
    // Find the inbox folder
    const inbox = allFolders.find(f => isInboxFolder(f));
    
    if (inbox) {
      log(`[InboxLookup] Found inbox for account ${accountId}: '${inbox.name}' (path='${inbox.path}')`, 'debug');
    } else {
      log(`[InboxLookup] No inbox found for account ${accountId}`, "warn");
    }
    
    return inbox;
  } catch (e) {
    log(`[InboxLookup] Error finding inbox for account ${accountId}: ${e}`, "error");
    return null;
  }
}

/**
 * Builds the full inbox context as an *array* of objects, then returns the
 * JSON string representation. The caller can JSON.parse if a JS object is
 * required.
 *
 * Each entry has the following shape:
 *   {
 *     uniqueId: string,          // Globally-unique message key (folderUri:headerID)
 *     internalId: number,        // Thunderbird internal numeric message id (fast look-ups)
 *     subject: string,
 *     from: string,              // "Author" field (name <email>)
 *     blurb: string,             // Oneâ€“line summary generated by LLM
 *     todos: string,             // Extracted action items (only included for action="reply")
 *     action: string             // One of "delete" | "archive" | "reply" | "" (empty if none)
 *     date: string               // Localized date string (e.g., MM/DD/YY)
 *     replied: boolean           // Whether the email has been replied to
 *   }
 *
 * Heavy LLM calls (summary generation) are throttled by summary.js & llm.js
 * semaphores, so we simply launch them in parallel here.
 */
export async function buildInboxContext() {
  const contextArray = [];
  const allMessages = []; // Collect all messages for bulk replied status check
  const maxEmails = SETTINGS.inboxManagement?.maxRecentEmails || 100;
  
  try {
    const accounts = await browser.accounts.list();

    for (const acc of accounts) {
      try {
        if (!acc.rootFolder) continue;

        // Use centralized inbox lookup
        const inboxFolder = await getInboxForAccount(acc.id);
        if (!inboxFolder) {
          continue;
        }

        // Paginate through message list to fetch all messages
        let page = await browser.messages.list(inboxFolder.id);
        while (page && page.messages && page.messages.length > 0) {
          for (const msg of page.messages) {
            allMessages.push(msg);
          }
          if (page.id) {
            page = await browser.messages.continueList(page.id);
          } else {
            break;
          }
        }
      } catch (subErr) {
        // log(`[TMDBG InboxContext] Error traversing account ${acc.name}: ${subErr}`);
      }
    }

    log(`[InboxContext] Collected ${allMessages.length} total inbox messages`, 'debug');

    // Sort all messages by date descending (most recent first)
    allMessages.sort((a, b) => {
      const dateA = a.date ? new Date(a.date).getTime() : 0;
      const dateB = b.date ? new Date(b.date).getTime() : 0;
      return dateB - dateA;
    });

    // Limit to most recent maxEmails
    const messagesToProcess = allMessages.slice(0, maxEmails);
    
    if (allMessages.length > maxEmails) {
      log(`[InboxContext] Inbox has ${allMessages.length} messages, limiting context to most recent ${maxEmails}`, 'debug');
    }

    // Process only the limited set of messages
    // Use Promise.all with indexed entries to maintain order
    const summaryPromises = messagesToProcess.map((msg, idx) => 
      _createContextEntry(msg).then(entry => ({ idx, entry }))
    );

    const results = await Promise.all(summaryPromises);
    
    // Sort by index to maintain original order, then extract entries
    results.sort((a, b) => a.idx - b.idx);
    for (const { entry } of results) {
      if (entry) {
        contextArray.push(entry);
      }
    }

    // Bulk fetch replied status for processed messages only
    try {
      const repliedStatuses = await _getRepliedStatusBulk(messagesToProcess);
      
      // Update contextArray with replied status (now order is guaranteed)
      for (let i = 0; i < contextArray.length; i++) {
        contextArray[i].replied = repliedStatuses[i] || false;
      }
      
      log(`[InboxContext] Successfully fetched replied status for ${contextArray.length} messages`, 'debug');
    } catch (e) {
      log(`[InboxContext] Failed to fetch replied status: ${e}`, "error");
      // Set all to false if bulk fetch fails
      for (let i = 0; i < contextArray.length; i++) {
        contextArray[i].replied = false;
      }
    }
  } catch (e) {
    // log(`[TMDBG InboxContext] Failed to build inbox context: ${e}`, "error");
  }

  return JSON.stringify(contextArray);
}

async function _createContextEntry(msgHeader) {
  try {
    // Determine current action via tags
    let action = "";
    const tags = msgHeader.tags || [];
    if (tags.includes(ACTION_TAG_IDS.delete)) action = "delete";
    else if (tags.includes(ACTION_TAG_IDS.archive)) action = "archive";
    else if (tags.includes(ACTION_TAG_IDS.reply)) action = "reply";

    // Fetch (or generate) summary blurb and todos
    let detailed = "";
    let blurb = "";
    let todos = "";
    try {
      const summaryObj = await getSummary(msgHeader, false, true); // cache only
      detailed = summaryObj?.detailed || "";
      blurb = summaryObj?.blurb || "";
      // Only include todos for emails marked as "reply"
      todos = (action === "reply") ? (summaryObj?.todos || "") : "";
    } catch (e) {
      // log(`[TMDBG InboxContext] Summary failed for message ${msgHeader.id}: ${e}`);
    }

    // Convert date using unified agent timestamp formatting for consistency.
    let dateStr = "";
    try {
      if (msgHeader.date) {
        const d = new Date(msgHeader.date);
        dateStr = formatTimestampForAgent(d);
      }
    } catch (_) { /* ignore formatting errors */ }

    // Check for attachments using header property
    const hasAttachmentsFlag = Boolean(msgHeader.hasAttachments);

    // Generate unique ID using centralized function
    const uniqueId = await getUniqueMessageKey(msgHeader);

    return {
      uniqueId: uniqueId || "",
      internalId: msgHeader.id,
      subject: msgHeader.subject || "",
      from: msgHeader.author || "",
      detailed,
      blurb,
      todos,
      action,
      date: dateStr,
      hasAttachments: hasAttachmentsFlag,
      replied: false, // Will be updated by bulk fetch
    };
  } catch (e) {
    // log(`[TMDBG InboxContext] Error processing message ${msgHeader?.id}: ${e}`);
    return null;
  }
}

/**
 * Bulk fetch replied status for all messages using tmHdr experiment
 * @param {Array} messages - Array of message headers
 * @returns {Promise<Array<boolean>>} - Array of replied status for each message
 */
async function _getRepliedStatusBulk(messages) {
  try {
    if (!messages || messages.length === 0) {
      return [];
    }

    // Build items array for getRepliedBulk
    const items = messages.map((msg, idx) => {
      const item = {
        folderURI: msg.folder?.id || "",
        key: msg.id,
        pathStr: msg.folder?.path || "",
        messageId: msg.headerMessageId || ""
      };
      
      // Log first few items for debugging
      if (idx < 3) {
        log(`[InboxContext] Sample item ${idx}: folderURI="${item.folderURI}", key=${item.key}, pathStr="${item.pathStr}", messageId="${item.messageId}"`, 'debug');
      }
      
      return item;
    });

    log(`[InboxContext] Calling tmHdr.getRepliedBulk for ${items.length} messages`, 'debug');
    
    // Call the bulk API
    const results = await browser.tmHdr.getRepliedBulk(items);
    
    log(`[InboxContext] tmHdr.getRepliedBulk returned ${results.length} results`, 'debug');
    
    // Log summary of results
    const trueCount = results.filter(r => r === true).length;
    const falseCount = results.filter(r => r === false).length;
    log(`[InboxContext] Replied status: ${trueCount} true, ${falseCount} false out of ${results.length} total`, 'debug');
    
    // Log first few results for debugging
    for (let i = 0; i < Math.min(5, results.length); i++) {
      log(`[InboxContext] Result[${i}]: ${results[i]} (subject: "${messages[i]?.subject}")`, 'debug');
    }
    
    return results;
  } catch (e) {
    log(`[InboxContext] Error in _getRepliedStatusBulk: ${e}`, "error");
    // Return array of false values on error
    return new Array(messages.length).fill(false);
  }
} 